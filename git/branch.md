## Принципы именования работы с ветками

**Определения**
- cherry-pick используется для того чтобы взять изменения, 
внесённые каким-либо коммитом, и попытаться применить их заново 
в виде нового коммита наверху текущей ветки. 
Это может оказаться полезным чтобы забрать парочку коммитов из другой 
ветки без полного слияния с той веткой.

- rebase — это "автоматизированный" cherry-pick.
Он выполняет ту же работу, но для цепочки коммитов, 
тем самым как бы перенося ветку на новое место.  

- Ветки в гите - это перемещаемые указатели на коммиты. 
После слияния указатель перемещается на мерж-коммит, 
а в предыдущих коммитах нет никакой информации о принадлежности к ветке.
  
**Основные правила:**

-  Ветки строятся на базе какого либо коммита и на базе тех коммитов которые есть;

- В ветке сохраняется только то изменение, которое мы делаем

- Ветка в гите - это перемещаемый, именованный указатель на конкретный коммит и все те файлы, 
которые были в рабочей копии остались не изменны, в новом коммите ветки размещается то содержимое и изменения,
которые мы отправили; 

- Во время заливания ветки в репозиторий, с точки зрения веток происходит следующее, 
те ветки которых на удаленном репозитории нет те создаются, а те втеки которые есть,
они обновляются и индексы меняются.

- во время совместной разработки, может возникнуть ситуация, когда нужно перетащить 
изменения из одной ветки в свою, для этого необходимо перейти в  ветку (chekout branch) 
и можно использовать команду Cherry pick this commit... Данная команда берет изменения 
из коммита чужой ветки и пытается добавить на текущую ветку. Этим удобно пользоваться, когда необходимы
либо изменения, а не весь функционал.

- если необходимо объединить ветки, 
то лучше всего использовать функцию rebase current branch -> selected commit , так как 
она переносит все коммиты из ветки в мастер после чего делается merge, 
таким образом лучше отслеживать изменения. Для этого заходим ветку которую собираемся
залить в ту или иную ветку, выделяем ветку, в которую будем вливать изменения и выполняем 
rebase, после чего делаем merge. 

- Pull лучше избегать, потому что неизвестно что придет и для этого использовать Fetch,
который позволяет смотреть изменения и регулировать объединения

- Квазилинейная история лучше

- Главная ценность истории - удобство сопровождения, поиска и анализа. 
В истории кода необходимы корректные, компактные, хорошо читаемые изменения, 
вместо реального извилистого пути полного проб и ошибок.


**Различия между merge и rebase**

- Merge создает дополнительный commit сливающий изменения

- Rebase позволяет вашей ветке получить изменение от другой путем 
надставления коммита вашей ветке
над той изменения которой вы хотите принять

**Решение конфликтов**

- При конфликте лучше использовать kdiff3 где вполне удобно редактировать конфликты.

- 